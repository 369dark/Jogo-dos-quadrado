<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo dos Quadrados</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:#fff;
    height:100%; width:100%;
    user-select:none;
    -webkit-user-select:none;
    -webkit-tap-highlight-color: transparent;
    font-family: Arial, sans-serif;
  }
  #gameCanvas {
    display:block;
    background: #fff;
    position: absolute;
    top:0; left:0;
    width: 100vw; height: 100vh;
  }
  #btnRestart {
    position: fixed;
    top: 10px; right: 10px;
    font-size: 16px;
    padding: 8px 12px;
    background: #333; color: #fff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 100;
  }
  #info {
    position: fixed;
    top: 10px; left: 10px;
    font-size: 18px;
    color: #222;
    user-select:none;
    z-index: 100;
  }
  #controls {
    position: fixed;
    bottom: 20px; left: 50%;
    transform: translateX(-50%);
    width: 160px; height: 160px;
    touch-action: none;
    user-select:none;
    z-index: 100;
  }
  .arrow {
    width: 50px; height: 50px;
    background: #ccc;
    opacity: 0.7;
    border-radius: 10px;
    position: absolute;
    user-select:none;
  }
  .arrow:active {
    background: #888;
  }
  #left { left: 0; top: 50%; transform: translateY(-50%); }
  #right { right: 0; top: 50%; transform: translateY(-50%); }
  #up { left: 50%; top: 0; transform: translateX(-50%); }
  #down { left: 50%; bottom: 0; transform: translateX(-50%); }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<button id="btnRestart" style="display:none;">Reiniciar</button>
<div id="info">Vidas: 2 | Moedas: 0</div>
<div id="controls">
  <div class="arrow" id="up">&#9650;</div>
  <div class="arrow" id="down">&#9660;</div>
  <div class="arrow" id="left">&#9668;</div>
  <div class="arrow" id="right">&#9658;</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let WIDTH = window.innerWidth;
  let HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  const btnRestart = document.getElementById('btnRestart');
  const info = document.getElementById('info');

  // Player
  let player = {
    x: 0,
    y: 0,
    size: 40,
    speed: 3,
    maxSpeed: 6,
    baseSpeed: 3,
    lives: 2,
    maxLives: 25,
    coins: 0,
    speedTimer: 0,
    slowEnemiesTimer: 0,
    shield: false,
    shieldTimer: 0,
    sizeUpTimer: 0
  };

  // Map control
  const spawnDistance = 500;
  const stopChaseDistance = 600;

  // Game state
  let gameOverFlag = false;
  let deathReason = '';
  let lastSpawn = 0;

  // Arrays
  let coins = [];
  let enemies = [];
  let items = [];

  // Touch controls
  let keys = {
    left: false,
    right: false,
    up: false,
    down: false
  };

  // Bee (círculo amarelo) toca 3 vezes para matar
  let beeTouches = 0;

  // Enemy types
  const ENEMY_TYPES = {
    COMMON: 'common', // azul quadrado
    MAX: 'max',       // rosa quadrado
    BEE: 'bee'        // círculo amarelo
  };

  // Item types
  const ITEM_TYPES = {
    LIFE: 'life',          // verde
    SPEED: 'speed',        // roxo
    SLOW_ENEMIES: 'slow',  // laranja
    SHIELD: 'shield',      // ciano (novo item)
    SIZEUP: 'sizeup'       // rosa claro (novo item)
  };

  // Spawn intervals
  const spawnInterval = 8000; // ms

  // Movement vector
  let moveX = 0;
  let moveY = 0;

  // Gamepad support
  let gamepadIndex = null;

  // Helper functions
  function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  // Spawn functions
  function spawnCoin() {
    coins.push({
      x: player.x + (Math.random() - 0.5) * 2000,
      y: player.y + (Math.random() - 0.5) * 2000,
      size: 20
    });
  }

  function spawnItem() {
    const itemTypes = [ITEM_TYPES.LIFE, ITEM_TYPES.SPEED, ITEM_TYPES.SLOW_ENEMIES, ITEM_TYPES.SHIELD, ITEM_TYPES.SIZEUP];
    const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
    items.push({
      x: player.x + (Math.random() - 0.5) * 2000,
      y: player.y + (Math.random() - 0.5) * 2000,
      size: 30,
      type
    });
  }

  function spawnEnemy(type) {
    // Spawn enemy at random position at least spawnDistance from player
    let ex, ey;
    do {
      ex = player.x + (Math.random() - 0.5) * 2000;
      ey = player.y + (Math.random() - 0.5) * 2000;
    } while(distance({x: ex, y: ey}, player) < spawnDistance);

    enemies.push({
      x: ex,
      y: ey,
      size: 40,
      type,
      touches: 0,
      baseSpeed: 2,
      speed: 2,
      slowTimer: 0
    });
  }

  function spawnEnemiesBatch() {
    for (let i = 0; i < 3; i++) {
      spawnEnemy(ENEMY_TYPES.COMMON);
    }
    // Chance to spawn rare enemies
    if (Math.random() < 0.05) spawnEnemy(ENEMY_TYPES.MAX);
    if (!enemies.some(e => e.type === ENEMY_TYPES.BEE) && Math.random() < 0.03) spawnEnemy(ENEMY_TYPES.BEE);
  }

  // Initialize
  function resetGame() {
    player.x = 0;
    player.y = 0;
    player.lives = 2;
    player.speed = player.baseSpeed;
    player.coins = 0;
    player.shield = false;
    player.shieldTimer = 0;
    player.size = 40;
    player.sizeUpTimer = 0;
    beeTouches = 0;
    enemies = [];
    coins = [];
    items = [];
    gameOverFlag = false;
    deathReason = '';
    lastSpawn = performance.now();
    spawnEnemiesBatch();
    for(let i=0; i<20; i++) spawnCoin();
    for(let i=0; i<3; i++) spawnItem();
    btnRestart.style.display = 'none';
    updateInfo();
  }

  // Update info text
  function updateInfo() {
    info.textContent = `Vidas: ${player.lives} | Moedas: ${player.coins}`;
  }

  // Game Over
  function gameOver(reason) {
    gameOverFlag = true;
    deathReason = reason;
    btnRestart.style.display = 'block';
  }

  // Controls for touchscreen arrows
  document.getElementById('left').addEventListener('touchstart', e => { keys.left = true; e.preventDefault(); });
  document.getElementById('left').addEventListener('touchend', e => { keys.left = false; e.preventDefault(); });
  document.getElementById('right').addEventListener('touchstart', e => { keys.right = true; e.preventDefault(); });
  document.getElementById('right').addEventListener('touchend', e => { keys.right = false; e.preventDefault(); });
  document.getElementById('up').addEventListener('touchstart', e => { keys.up = true; e.preventDefault(); });
  document.getElementById('up').addEventListener('touchend', e => { keys.up = false; e.preventDefault(); });
  document.getElementById('down').addEventListener('touchstart', e => { keys.down = true; e.preventDefault(); });
  document.getElementById('down').addEventListener('touchend', e => { keys.down = false; e.preventDefault(); });

  // Restart button
  btnRestart.addEventListener('click', () => {
    resetGame();
  });

  // Gamepad
  window.addEventListener("gamepadconnected", function(e) {
    gamepadIndex = e.gamepad.index;
  });
  window.addEventListener("gamepaddisconnected", function(e) {
    if(gamepadIndex === e.gamepad.index) {
      gamepadIndex = null;
    }
  });

  // Main update loop
  function update(delta) {
    if(gameOverFlag) return;

    // Update timers
    if(player.speedTimer > 0) {
      player.speedTimer -= delta;
      if(player.speedTimer <= 0) {
        player.speed = player.baseSpeed;
      }
    }

    if(player.slowEnemiesTimer > 0) {
      player.slowEnemiesTimer -= delta;
      if(player.slowEnemiesTimer <= 0) {
        enemies.forEach(e => e.speed = e.baseSpeed);
      }
    }

    if(player.shieldTimer > 0) {
      player.shieldTimer -= delta;
      if(player.shieldTimer <= 0) {
        player.shield = false;
      }
    }

    if(player.sizeUpTimer > 0) {
      player.sizeUpTimer -= delta;
      if(player.sizeUpTimer <= 0) {
        player.size = 40;
      }
    }

    // Update player velocity by keys
    moveX = 0;
    moveY = 0;
    if(keys.left) moveX -= 1;
    if(keys.right) moveX += 1;
    if(keys.up) moveY -= 1;
    if(keys.down) moveY += 1;

    // Gamepad input
    if(gamepadIndex !== null) {
      const gp = navigator.getGamepads()[gamepadIndex];
      if(gp) {
        const deadzone = 0.2;
        let axisX = gp.axes[0];
        let axisY = gp.axes[1];
        if(Math.abs(axisX) < deadzone) axisX = 0;
        if(Math.abs(axisY) < deadzone) axisY = 0;
        moveX = axisX;
        moveY = axisY;
      }
    }

    // Normalize movement
    if(moveX !== 0 || moveY !== 0) {
      const len = Math.hypot(moveX, moveY);
      moveX /= len;
      moveY /= len;
    }

    player.x += moveX * player.speed;
    player.y += moveY * player.speed;

    // Limitar mapa infinito não precisa (player pode andar livremente)

    // Atualizar inimigos
    enemies.forEach(e => {
      // Slow timer decrement
      if(e.slowTimer > 0) {
        e.slowTimer -= delta;
        if(e.slowTimer <= 0) e.speed = e.baseSpeed;
      }

      // Checar distância do player para perseguir
      const dist = distance(player, e);
      if(dist <= stopChaseDistance) {
        // Perseguir o player
        let dirX = player.x - e.x;
        let dirY = player.y - e.y;
        const len = Math.hypot(dirX, dirY);
        if(len > 0) {
          dirX /= len;
          dirY /= len;
          e.x += dirX * e.speed;
          e.y += dirY * e.speed;
        }
      }
      // Se afastar, inimigos param (não se movem)
    });

    // Colisões

    // Colisão com moedas
    for(let i = coins.length - 1; i >= 0; i--) {
      const c = coins[i];
      if(distance(player, c) < (player.size/2 + c.size/2)) {
        coins.splice(i, 1);
        player.coins++;
        player.size += 1;
        player.sizeUpTimer = 8000; // dura 8s
        if(player.size > 80) player.size = 80;
      }
    }

    // Colisão com itens
    for(let i = items.length - 1; i >= 0; i--) {
      const it = items[i];
      if(distance(player, it) < (player.size/2 + it.size/2)) {
        switch(it.type) {
          case ITEM_TYPES.LIFE:
            player.lives++;
            if(player.lives > player.maxLives) player.lives = player.maxLives;
            break;
          case ITEM_TYPES.SPEED:
            player.speed = player.maxSpeed;
            player.speedTimer = 8000;
            break;
          case ITEM_TYPES.SLOW_ENEMIES:
            enemies.forEach(e => {
              e.speed = 0.8;
              e.slowTimer = 8000;
            });
            player.slowEnemiesTimer = 8000;
            break;
          case ITEM_TYPES.SHIELD:
            player.shield = true;
            player.shieldTimer = 10000;
            break;
          case ITEM_TYPES.SIZEUP:
            player.size = 80;
            player.sizeUpTimer = 8000;
            break;
        }
        items.splice(i, 1);
      }
    }

    // Colisão com inimigos
    for(let e of enemies) {
      const dist = distance(player, e);
      if(dist < (player.size/2 + e.size/2)) {
        if(e.type === ENEMY_TYPES.COMMON) {
          // Quadrado azul - tira 1 vida
          if(!player.shield) {
            player.lives--;
            if(player.lives <= 0) {
              gameOver('Você foi morto por inimigo comum');
            }
          }
          // Para evitar perder várias vidas rapidinho, empurre inimigo pra longe
          e.x += (e.x - player.x) * 50;
          e.y += (e.y - player.y) * 50;
        } else if(e.type === ENEMY_TYPES.MAX) {
          // Quadrado rosa - tira 5 vidas
          if(!player.shield) {
            player.lives -= 5;
            if(player.lives <= 0) {
              gameOver('Você morreu por inimigo max');
            }
          }
          e.x += (e.x - player.x) * 50;
          e.y += (e.y - player.y) * 50;
        } else if(e.type === ENEMY_TYPES.BEE) {
          // Círculo amarelo - precisa encostar 3 vezes
          if(!player.shield) {
            beeTouches++;
            if(beeTouches >= 3) {
              gameOver('Você morreu por abelha');
            }
          }
          // Empurra a abelha longe
          e.x += (e.x - player.x) * 50;
          e.y += (e.y - player.y) * 50;
        }
      }
    }

    // Spawn coins and items if necessário para encher o mapa
    if(coins.length < 30) spawnCoin();
    if(items.length < 5 && Math.random() < 0.01) spawnItem();

    // Spawn enemies se menos que 3 comuns
    if(enemies.filter(e => e.type === ENEMY_TYPES.COMMON).length < 3) {
      spawnEnemy(ENEMY_TYPES.COMMON);
    }
    // Spawn raros eventualmente
    if(!enemies.some(e => e.type === ENEMY_TYPES.MAX) && Math.random() < 0.002) spawnEnemy(ENEMY_TYPES.MAX);
    if(!enemies.some(e => e.type === ENEMY_TYPES.BEE) && Math.random() < 0.001) spawnEnemy(ENEMY_TYPES.BEE);

    updateInfo();
  }

  // Desenhar tudo
  function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Calcular offset para centralizar o player
    const offsetX = player.x - WIDTH/2;
    const offsetY = player.y - HEIGHT/2;

    // Desenhar moedas (amarelas quadrados)
    coins.forEach(c => {
      const x = c.x - offsetX;
      const y = c.y - offsetY;
      ctx.fillStyle = 'yellow';
      ctx.fillRect(x - c.size/2, y - c.size/2, c.size, c.size);
    });

    // Desenhar itens
    items.forEach(it => {
      const x = it.x - offsetX;
      const y = it.y - offsetY;
      switch(it.type) {
        case ITEM_TYPES.LIFE:
          ctx.fillStyle = 'green';
          break;
        case ITEM_TYPES.SPEED:
          ctx.fillStyle = 'purple';
          break;
        case ITEM_TYPES.SLOW_ENEMIES:
          ctx.fillStyle = 'orange';
          break;
        case ITEM_TYPES.SHIELD:
          ctx.fillStyle = 'cyan';
          break;
        case ITEM_TYPES.SIZEUP:
          ctx.fillStyle = '#ffb6c1'; // rosa claro
          break;
      }
      ctx.fillRect(x - it.size/2, y - it.size/2, it.size, it.size);
    });

    // Desenhar inimigos
    enemies.forEach(e => {
      const x = e.x - offsetX;
      const y = e.y - offsetY;
      if(e.type === ENEMY_TYPES.COMMON) {
        ctx.fillStyle = 'blue';
        ctx.fillRect(x - e.size/2, y - e.size/2, e.size, e.size);
      } else if(e.type === ENEMY_TYPES.MAX) {
        ctx.fillStyle = 'pink';
        ctx.fillRect(x - e.size/2, y - e.size/2, e.size, e.size);
      } else if(e.type === ENEMY_TYPES.BEE) {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(x, y, e.size/2, 0, Math.PI*2);
        ctx.fill();
      }
    });

    // Desenhar jogador (quadrado vermelho)
    const px = WIDTH/2;
    const py = HEIGHT/2;
    ctx.fillStyle = player.shield ? 'cyan' : 'red';
    ctx.fillRect(px - player.size/2, py - player.size/2, player.size, player.size);

    // Se game over, mostrar texto centralizado menor e dentro da tela
    if(gameOverFlag) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, HEIGHT/2 - 50, WIDTH, 100);
      ctx.fillStyle = 'white';
      ctx.font = '28px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(deathReason, WIDTH/2, HEIGHT/2);
    }
  }

  // Loop principal
  let lastTime = 0;
  function loop(timestamp=0) {
    const delta = timestamp - lastTime;
    lastTime = timestamp;

    update(delta);
    draw();

    requestAnimationFrame(loop);
  }

  // Ajustar canvas tamanho na janela redimensionada
  window.addEventListener('resize', () => {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  });

  // Iniciar jogo
  resetGame();
  requestAnimationFrame(loop);

})();
</script>

</body>
</html>
