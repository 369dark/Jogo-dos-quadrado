<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jogo dos Quadrados — Versão 1.4</title>
<style>
  html,body{
    margin:0;padding:0;height:100%;overflow:hidden;background:#fff;font-family:Arial,Helvetica,sans-serif;user-select:none
  }
  canvas{
    display:block;background:#fff
  }
  #ui{
    position:fixed;left:12px;top:10px;z-index:20;font-weight:bold;color:#222;
  }
  #ui h2 {
    margin: 0 12px 0 0;
    display: inline;
    font-size: 1.6em;
    font-weight: bold;
    color: #222;
  }
  #message{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    z-index:30;background:rgba(255,255,255,0.96);
    padding:18px 26px;border-radius:12px;font-size:22px;color:#b00;
    display:none;max-width:90vw;text-align:center;
  }
  #restart-btn{
    position:fixed;left:50%;top:calc(50% + 80px);
    transform:translateX(-50%);
    z-index:31;padding:16px 26px;border-radius:12px;
    border:0;background:#222;color:#fff;font-size:22px;
    cursor:pointer;display:none;
  }
  /* touch controls */
  #controls{
    position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
    width:180px;height:140px;z-index:25
  }
  .btn-arrow{
    position:absolute;width:60px;height:60px;border-radius:12px;
    background:#ddd;box-shadow:0 2px 6px rgba(0,0,0,.15);
    text-align:center;line-height:60px;font-size:30px;cursor:pointer
  }
  .btn-arrow:active{
    background:#bbb;
  }
  #btn-up{ left:60px; top:0 }
  #btn-left{ left:0; top:70px }
  #btn-down{ left:60px; top:70px }
  #btn-right{ left:120px; top:70px }

  /* Apito botão triângulo amarelo no canto inferior direito */
  #whistle-btn {
    position: fixed;
    right: 24px;
    bottom: 24px;
    width: 60px;
    height: 60px;
    background: #ffdc4d;
    clip-path: polygon(0% 100%, 100% 50%, 0% 0%);
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 40;
    transition: background 0.3s ease;
    user-select: none;
    border: none;
  }
  #whistle-btn:active {
    background: #e6c843;
  }
  #whistle-cooldown {
    position: absolute;
    left: 0; top: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.3);
    clip-path: polygon(0% 100%, 100% 50%, 0% 0%);
    pointer-events: none;
    transform-origin: center bottom;
    transform: scaleY(0);
    transition: transform 0.3s linear;
    z-index: 41;
  }
</style>
</head>
<body>
  <div id="ui">
    <h2>Vidas: <span id="life-count">2</span></h2>
    <h2>Moedas: <span id="coin-count">0</span></h2>
  </div>
  <div id="message"></div>
  <button id="restart-btn">Reiniciar</button>

  <canvas id="game"></canvas>

  <div id="controls">
    <div class="btn-arrow" id="btn-up">↑</div>
    <div class="btn-arrow" id="btn-left">←</div>
    <div class="btn-arrow" id="btn-down">↓</div>
    <div class="btn-arrow" id="btn-right">→</div>
  </div>

  <button id="whistle-btn" title="Congelar inimigos (apito)">
    <div id="whistle-cooldown"></div>
  </button>

<script>
(() => {
  // --- Setup Canvas ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
  canvas.width = WIDTH; canvas.height = HEIGHT;

  // UI
  const lifeCountElem = document.getElementById('life-count');
  const coinCountElem = document.getElementById('coin-count');
  const messageElem = document.getElementById('message');
  const restartBtn = document.getElementById('restart-btn');

  // Apito
  const whistleBtn = document.getElementById('whistle-btn');
  const whistleCooldownOverlay = document.getElementById('whistle-cooldown');
  const WHISTLE_COOLDOWN_MS = 15000; // 15 segundos de cooldown
  const WHISTLE_FREEZE_MS = 5000; // congela inimigos por 5 segundos
  let whistleAvailable = true;
  let whistleCooldownStart = 0;

  // Configs
  const ITEM_RESPAWN_INTERVAL_MS = 4000; // 4 segundos
  const ITEM_MIN_DIST = 500; // distância minima do jogador
  const ENEMY_STOP_DISTANCE = 600; // inimigos param de perseguir se > 600px
  const PLAYER_MAX_LIVES = 25;
  const BEE_HITS_TO_KILL = 3;
  const DAMAGE_COOLDOWN_MS = 1000; // 1s cooldown por inimigo

  // Cores e tamanhos
  const COLORS = {
    player: '#d11', // vermelho quadrado jogador
    coin: '#ffdc4d', // amarelo moeda
    enemyCommon: '#2b6cff', // azul quadrado inimigo comum
    enemyMax: '#ff65b2', // rosa quadrado inimigo max
    bee: '#ffc34d', // laranja abelha
    life: '#2ecc71', // verde
    speed: '#8b5cf6', // roxo quadrado velocidade
    slowEnemy:'#ff8a3d', // laranja escuro
    shield: '#4ce0e6', // ciano escudo
    extra:'#00bcd4', // azul raro (aumenta 20%)
    invincible: '#888', // cinza invencivel
  };
  const SIZES = {
    player: 36,
    coin: 18,
    enemyCommon: 36,
    enemyMax: 48,
    bee: 26,
    life: 22,
    speed: 22,
    slowEnemy: 22,
    shield: 26,
    extra: 26,
    invincible: 28,
  };

  // Estado do jogo
  let gameOver = false;
  let deathReason = '';

  // Congelamento inimigos
  let enemiesFrozen = false;
  let freezeTimer = 0;

  // Controles (teclado, touch, mouse drag)
  const keys = { left:false, right:false, up:false, down:false };
  const btnUp = document.getElementById('btn-up');
  const btnDown = document.getElementById('btn-down');
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');

  function bindBtn(btn, dir) {
    btn.addEventListener('pointerdown', e => { keys[dir]=true; e.preventDefault(); });
    btn.addEventListener('pointerup', e => { keys[dir]=false; e.preventDefault(); });
    btn.addEventListener('pointerleave', e => { keys[dir]=false; e.preventDefault(); });
    btn.addEventListener('touchcancel', e => { keys[dir]=false; e.preventDefault(); });
  }
  bindBtn(btnUp,'up'); bindBtn(btnDown,'down'); bindBtn(btnLeft,'left'); bindBtn(btnRight,'right');

  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowUp') keys.up = true;
    if(e.key === 'ArrowDown') keys.down = true;
    if(e.key === 'ArrowLeft') keys.left = true;
    if(e.key === 'ArrowRight') keys.right = true;
  });
  window.addEventListener('keyup', e => {
    if(e.key === 'ArrowUp') keys.up = false;
    if(e.key === 'ArrowDown') keys.down = false;
    if(e.key === 'ArrowLeft') keys.left = false;
    if(e.key === 'ArrowRight') keys.right = false;
  });

  // Mouse drag / pointer control: ao arrastar/clicar no canvas o jogador se move na direção do cursor
  let pointerActive = false;
  canvas.addEventListener('pointerdown', (e) => { pointerActive = true; handlePointerMove(e); canvas.style.cursor='pointer'; });
  canvas.addEventListener('pointerup', (e)=>{ pointerActive = false; resetKeys(); canvas.style.cursor='default'; });
  canvas.addEventListener('pointercancel', ()=>{ pointerActive=false; resetKeys(); canvas.style.cursor='default' });
  canvas.addEventListener('mouseleave', ()=>{ pointerActive=false; resetKeys(); canvas.style.cursor='default' });
  canvas.addEventListener('pointermove', (e) => { if(pointerActive) handlePointerMove(e); });

  function resetKeys(){ keys.left=keys.right=keys.up=keys.down=false; }
  function handlePointerMove(e){
    // calcula direção do centro (player) para o ponteiro
    const cx = WIDTH/2, cy = HEIGHT/2;
    const dx = e.clientX - cx, dy = e.clientY - cy;
    const dead = 10; // zona morta
    keys.left = dx < -dead;
    keys.right = dx > dead;
    keys.up = dy < -dead;
    keys.down = dy > dead;
  }

  // Entidades do mundo (coordenadas absolutas)
  const player = {
    x: 0, y: 0,
    size: SIZES.player,
    speed: 3,
    maxSpeed: 6,
    lives: 2,
    coins: 0,
    sizeIncrease: 0,
    fastTimer: 0,
    slowEnemyTimer: 0,
    shieldTimer: 0,
    invincibleTimer: 0,
  };

  let coins = []; // {x,y,size}
  let items = []; // {x,y,size,type}
  let enemies = []; // {x,y,size,type,speed,lastHitTime,hitsOnPlayer,lastDamageTime,hitsOnPlayer}

  // utilitários
  function randAnglePos(minDist, maxDist) {
    const a = Math.random()*Math.PI*2;
    const r = minDist + Math.random()*(maxDist-minDist);
    return { x: player.x + Math.cos(a)*r, y: player.y + Math.sin(a)*r };
  }
  function distance(ax,ay,bx,by){ return Math.hypot(ax-bx,ay-by); }

  // UI update
  function updateUI(){ 
    lifeCountElem.textContent = player.lives; 
    coinCountElem.textContent = player.coins; 
  }

  // spawn inicial de mundo
  function spawnInitial(){
    coins = []; items = []; enemies = [];
    player.x = 0; player.y = 0; 
    player.lives = 2; player.coins = 0; 
    player.sizeIncrease=0; 
    player.fastTimer=0; player.slowEnemyTimer=0; 
    player.shieldTimer=0; 
    player.invincibleTimer=0;
    enemiesFrozen = false;
    freezeTimer = 0;

    // moedas iniciais
    for(let i=0;i<50;i++){ 
      const p = randAnglePos(300,1400); 
      coins.push({x:p.x,y:p.y,size:SIZES.coin}); 
    }
    // itens iniciais
    for(let i=0;i<8;i++){ 
      const p = randAnglePos(400,1400); 
      items.push({x:p.x,y:p.y,size:SIZES.life,type:chooseItemType()}); 
    }
    // inimigos iniciais: 3 azuis
    for(let i=0;i<3;i++){ 
      const p = randAnglePos(600,1200); 
      enemies.push({x:p.x,y:p.y,size:SIZES.enemyCommon,type:'enemyCommon',speed:1.6,lastHitTime:0}); 
    }
    // 1 inimigo rosa (raro)
    if(Math.random() < 0.6){ 
      const p = randAnglePos(600,1200); 
      enemies.push({x:p.x,y:p.y,size:SIZES.enemyMax,type:'enemyMax',speed:1.2,lastHitTime:0}); 
    }
    // 1 abelha (raríssima - 20%)
    if(Math.random() < 0.2 && !enemies.some(e=>e.type==='bee')){ 
      const p = randAnglePos(700,1400); 
      enemies.push({x:p.x,y:p.y,size:SIZES.bee,type:'bee',speed:2.6,hitsOnPlayer:0,lastHitTime:0}); 
    }
    gameOver=false; deathReason=''; 
    updateUI();
  }

  // Escolhe tipo de item com probabilidades
  function chooseItemType(){
    const r = Math.random();
    if(r < 0.25) return 'life';           // 25% vida
    if(r < 0.40) return 'coinpack';       // 15% pacote de moedas (gera várias)
    if(r < 0.55) return 'speed';          // 15% velocidade (roxo)
    if(r < 0.70) return 'slowEnemy';      // 15% inimigos lentos (laranja escuro)
    if(r < 0.80) return 'shield';         // 10% escudo (ciano)
    if(r < 0.90) return 'invincible';     // 10% invencível (cinza)
    if(r < 0.98) return 'extra';           // 8% aumenta 20% (azul círculo)
    return 'life'; // fallback
  }

  // Função que cria itens/coins periodicamente (a cada 4s)
  function spawnItemsPeriodically(){
    // spawn algumas moedas e eventualmente um item
    // spawn 1-3 moedas + possível 1 item
    const coinCount = 1 + Math.floor(Math.random()*3);
    for(let i=0;i<coinCount;i++){
      const p = randAnglePos(ITEM_MIN_DIST, 1600);
      coins.push({x:p.x,y:p.y,size:SIZES.coin});
    }
    // 80% chance de spawn de pelo menos 1 item
    if(Math.random() < 0.85){
      const p = randAnglePos(ITEM_MIN_DIST, 1600);
      items.push({x:p.x,y:p.y,size:SIZES.life,type:chooseItemType()});
    }
  }

  // Colisões
  function rectsCollide(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }
  function circleRectCollide(cx,cy,cr,rx,ry,rw,rh){
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX, dy = cy - closestY;
    return (dx*dx+dy*dy) < (cr*cr);
  }

  // Update do jogador
  function updatePlayer(){
    let s = player.speed;
    if(player.fastTimer > 0){ s = player.maxSpeed; player.fastTimer--; }
    const dx = ((keys.right?1:0)-(keys.left?1:0));
    const dy = ((keys.down?1:0)-(keys.up?1:0));
    let mx = dx, my = dy;
    if(mx !== 0 && my !== 0){ mx *= Math.SQRT1_2; my *= Math.SQRT1_2; }
    player.x += mx * s;
    player.y += my * s;
    // decrement timers
    if(player.slowEnemyTimer>0) player.slowEnemyTimer--;
    if(player.shieldTimer>0) player.shieldTimer--;
    if(player.fastTimer>0) player.fastTimer--;
    if(player.invincibleTimer>0) player.invincibleTimer--;
  }

  // Update inimigos (perseguem se dentro de ENEMY_STOP_DISTANCE)
  function updateEnemies(){
    if(enemiesFrozen){
      freezeTimer--;
      if(freezeTimer <= 0){
        enemiesFrozen = false;
      }
      return; // congela inimigos
    }
    const slow = player.slowEnemyTimer > 0;
    enemies.forEach(e=>{
      const d = distance(e.x,e.y,player.x,player.y);
      if(d > ENEMY_STOP_DISTANCE) return;
      let sp = e.speed;
      if(slow) sp /= 2;
      // normaliza direção
      const dirX = (player.x - e.x)/d || 0;
      const dirY = (player.y - e.y)/d || 0;
      e.x += dirX * sp;
      e.y += dirY * sp;
    });
  }

  // Checa colisões (moedas, items e inimigos) e aplica efeitos
  function handleCollisions(){
    const pSize = player.size + player.sizeIncrease;
    const px = player.x - pSize/2, py = player.y - pSize/2;
    // moedas
    coins = coins.filter(coin => {
      const cx = coin.x, cy = coin.y, cr = coin.size;
      const dist = distance(player.x, player.y, cx, cy);
      if(dist < (pSize/2 + cr)){
        player.coins++;
        updateUI();
        return false; // moeda coletada
      }
      return true;
    });

    // itens
    items = items.filter(item => {
      const ix = item.x, iy = item.y, isz = item.size;
      const dist = distance(player.x, player.y, ix, iy);
      if(dist < (pSize/2 + isz)){
        // aplicar efeito do item
        switch(item.type){
          case 'life':
            if(player.lives < PLAYER_MAX_LIVES) player.lives++;
            break;
          case 'coinpack':
            player.coins += 5;
            break;
          case 'speed':
            player.fastTimer = 600; // 10 segundos (60fps)
            break;
          case 'slowEnemy':
            player.slowEnemyTimer = 600;
            break;
          case 'shield':
            player.shieldTimer = 300; // 5 segundos
            break;
          case 'invincible':
            player.invincibleTimer = 300;
            break;
          case 'extra':
            player.sizeIncrease += Math.floor(pSize * 0.2);
            break;
        }
        updateUI();
        return false; // item coletado
      }
      return true;
    });

    // inimigos
    enemies.forEach(e => {
      const ex = e.x, ey = e.y, esz = e.size;
      const dist = distance(player.x, player.y, ex, ey);
      if(dist < (pSize/2 + esz/2)){
        const now = Date.now();

        if(player.invincibleTimer > 0) return; // invencível não sofre dano

        // Proteção escudo
        if(player.shieldTimer > 0){
          // só remove o escudo e não tira vida
          player.shieldTimer = 0;
          return;
        }

        // Checa cooldown dano pra não tirar vida múltiplas vezes rápido
        if(!e.lastDamageTime) e.lastDamageTime = 0;
        if(now - e.lastDamageTime < DAMAGE_COOLDOWN_MS) return;

        // Dano conforme inimigo
        switch(e.type){
          case 'enemyCommon':
            player.lives -= 1;
            deathReason = "Você foi morto por inimigo comum.";
            break;
          case 'enemyMax':  // quadrado rosa
            player.lives -= 5;
            deathReason = "Você foi morto pelo inimigo MAX (rosa).";
            break;
          case 'bee':
            e.hitsOnPlayer = (e.hitsOnPlayer || 0) + 1;
            if(e.hitsOnPlayer >= BEE_HITS_TO_KILL){
              player.lives = 0;
              deathReason = "Você foi morto por abelha.";
            } else {
              player.lives -= 1;
              deathReason = "Você foi picado pela abelha.";
            }
            break;
        }
        e.lastDamageTime = now;
        updateUI();
      }
    });

    // Verifica fim de jogo
    if(player.lives <= 0 && !gameOver){
      gameOver = true;
      messageElem.textContent = deathReason || "Você morreu.";
      messageElem.style.display = "block";
      restartBtn.style.display = "block";
    }
  }

  // Desenha jogador
  function drawPlayer(){
    const size = player.size + player.sizeIncrease;
    ctx.save();
    ctx.translate(WIDTH/2, HEIGHT/2);

    // invencivel cinza
    if(player.invincibleTimer > 0){
      ctx.fillStyle = COLORS.invincible;
      ctx.shadowColor = '#999';
      ctx.shadowBlur = 15;
      ctx.fillRect(-size/2, -size/2, size, size);
    }

    // quadrado vermelho jogador
    ctx.fillStyle = COLORS.player;
    ctx.shadowColor = '#c00';
    ctx.shadowBlur = 15;
    ctx.fillRect(-size/2, -size/2, size, size);

    // escudo (ciano) efeito círculo transparente
    if(player.shieldTimer > 0){
      ctx.beginPath();
      ctx.strokeStyle = COLORS.shield;
      ctx.lineWidth = 5;
      ctx.shadowColor = COLORS.shield;
      ctx.shadowBlur = 15;
      ctx.arc(0, 0, size * 0.75, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Desenha moedas
  function drawCoins(){
    coins.forEach(c => {
      const dx = c.x - player.x + WIDTH/2;
      const dy = c.y - player.y + HEIGHT/2;
      ctx.fillStyle = COLORS.coin;
      ctx.beginPath();
      ctx.arc(dx, dy, c.size, 0, Math.PI*2);
      ctx.fill();
    });
  }

  // Desenha itens
  function drawItems(){
    items.forEach(i => {
      const dx = i.x - player.x + WIDTH/2;
      const dy = i.y - player.y + HEIGHT/2;

      switch(i.type){
        case 'life':
          ctx.fillStyle = COLORS.life;
          ctx.fillRect(dx - i.size/2, dy - i.size/2, i.size, i.size);
          break;
        case 'coinpack':
          ctx.fillStyle = COLORS.coin;
          ctx.beginPath();
          ctx.arc(dx, dy, i.size * 1.2, 0, Math.PI*2);
          ctx.fill();
          break;
        case 'speed':
          ctx.fillStyle = COLORS.speed;
          ctx.fillRect(dx - i.size/2, dy - i.size/2, i.size, i.size);
          break;
        case 'slowEnemy':
          ctx.fillStyle = COLORS.slowEnemy;
          ctx.fillRect(dx - i.size/2, dy - i.size/2, i.size, i.size);
          break;
        case 'shield':
          ctx.fillStyle = COLORS.shield;
          ctx.fillRect(dx - i.size/2, dy - i.size/2, i.size, i.size);
          break;
        case 'invincible':
          ctx.fillStyle = COLORS.invincible;
          ctx.fillRect(dx - i.size/2, dy - i.size/2, i.size, i.size);
          break;
        case 'extra':
          ctx.fillStyle = COLORS.extra;
          ctx.beginPath();
          ctx.arc(dx, dy, i.size, 0, Math.PI*2);
          ctx.fill();
          break;
      }
    });
  }

  // Desenha inimigos
  function drawEnemies(){
    enemies.forEach(e=>{
      const dx = e.x - player.x + WIDTH/2;
      const dy = e.y - player.y + HEIGHT/2;

      switch(e.type){
        case 'enemyCommon':
          ctx.fillStyle = COLORS.enemyCommon;
          ctx.fillRect(dx - e.size/2, dy - e.size/2, e.size, e.size);
          break;
        case 'enemyMax':
          ctx.fillStyle = COLORS.enemyMax;
          ctx.fillRect(dx - e.size/2, dy - e.size/2, e.size, e.size);
          break;
        case 'bee':
          // abelha: desenhar quadrado laranja menor e circular "asas"
          ctx.fillStyle = COLORS.bee;
          ctx.fillRect(dx - e.size/2, dy - e.size/2, e.size, e.size);
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.ellipse(dx - e.size/4, dy - e.size/4, e.size/5, e.size/8, 0, 0, Math.PI*2);
          ctx.ellipse(dx + e.size/4, dy - e.size/4, e.size/5, e.size/8, 0, 0, Math.PI*2);
          ctx.fill();
          break;
      }
    });
  }

  // Desenha fundo infinito (grade simples)
  function drawBackground(){
    const gridSize = 100;
    ctx.fillStyle = '#e5f5e0';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.strokeStyle = '#c7e2c9';
    ctx.lineWidth = 1;

    const offsetX = player.x % gridSize;
    const offsetY = player.y % gridSize;

    for(let x = -offsetX; x < WIDTH; x += gridSize){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, HEIGHT);
      ctx.stroke();
    }
    for(let y = -offsetY; y < HEIGHT; y += gridSize){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(WIDTH, y);
      ctx.stroke();
    }
  }

  // Loop principal
  function gameLoop(){
    if(gameOver){
      requestAnimationFrame(gameLoop);
      return;
    }

    updatePlayer();
    updateEnemies();
    handleCollisions();

    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    drawBackground();
    drawCoins();
    drawItems();
    drawEnemies();
    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  // Apito freeze controle
  whistleBtn.addEventListener('click', () => {
    if(!whistleAvailable) return;
    enemiesFrozen = true;
    freezeTimer = WHISTLE_FREEZE_MS / (1000/60); // frames (5 segundos)
    whistleAvailable = false;
    whistleCooldownStart = Date.now();

    // animação cooldown
    whistleCooldownOverlay.style.transform = 'scaleY(1)';

    // congela inimigos e inicia cooldown
    setTimeout(() => {
      enemiesFrozen = false;
    }, WHISTLE_FREEZE_MS);

    // cooldown do botão
    const cooldownInterval = setInterval(() => {
      const elapsed = Date.now() - whistleCooldownStart;
      if(elapsed >= WHISTLE_COOLDOWN_MS){
        whistleAvailable = true;
        whistleCooldownOverlay.style.transform = 'scaleY(0)';
        clearInterval(cooldownInterval);
      } else {
        const ratio = 1 - elapsed / WHISTLE_COOLDOWN_MS;
        whistleCooldownOverlay.style.transform = `scaleY(${ratio})`;
      }
    }, 100);
  });

  // Reiniciar jogo
  restartBtn.addEventListener('click', () => {
    spawnInitial();
    messageElem.style.display = 'none';
    restartBtn.style.display = 'none';
    gameOver = false;
  });

  // Redimensiona canvas ao mudar tamanho da tela
  window.addEventListener('resize', () => {
    WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
    canvas.width = WIDTH; canvas.height = HEIGHT;
  });

  // Spawn periódico de itens e moedas
  setInterval(() => {
    if(!gameOver) spawnItemsPeriodically();
  }, ITEM_RESPAWN_INTERVAL_MS);

  // Começa o jogo
  spawnInitial();
  gameLoop();

})();
</script>
</body>
</html>
