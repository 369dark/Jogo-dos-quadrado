<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo dos Quadrados Completo</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#fff;
    font-family: Arial, sans-serif;
    user-select:none;
  }
  canvas {
    display:block;
    background: white;
  }
  #ui {
    position: fixed;
    top: 10px; left: 10px;
    color: #333;
    font-weight: bold;
    font-size: 18px;
    z-index: 10;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    font-weight: bold;
    color: red;
    background: rgba(255,255,255,0.9);
    padding: 20px 40px;
    border-radius: 15px;
    display: none;
    z-index: 20;
    max-width: 90vw;
    text-align: center;
  }
  #restart-btn {
    position: fixed;
    top: calc(50% + 70px);
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    font-size: 20px;
    border: none;
    border-radius: 12px;
    background: #333;
    color: white;
    cursor: pointer;
    display: none;
    z-index: 20;
  }
  /* Controles setas clicáveis para PS4 cursor */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    width: 180px;
    height: 140px;
    user-select: none;
    z-index: 15;
  }
  .btn-arrow {
    position: absolute;
    width: 60px; height: 60px;
    background: #ccc;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    text-align: center;
    line-height: 60px;
    font-size: 36px;
    cursor: pointer;
    user-select: none;
  }
  .btn-arrow:active {
    background: #aaa;
  }
  #btn-up { top: 0; left: 60px; }
  #btn-left { top: 70px; left: 0; }
  #btn-down { top: 70px; left: 60px; }
  #btn-right { top: 70px; left: 120px; }
</style>
</head>
<body>

<div id="ui">Vidas: <span id="life-count">2</span> &nbsp; Moedas: <span id="coin-count">0</span></div>
<div id="message"></div>
<button id="restart-btn">Reiniciar</button>

<canvas id="game"></canvas>

<div id="controls">
  <div class="btn-arrow" id="btn-up">↑</div>
  <div class="btn-arrow" id="btn-left">←</div>
  <div class="btn-arrow" id="btn-down">↓</div>
  <div class="btn-arrow" id="btn-right">→</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Ajusta tamanho da tela
  let WIDTH = window.innerWidth;
  let HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  // UI elementos
  const lifeCountElem = document.getElementById('life-count');
  const coinCountElem = document.getElementById('coin-count');
  const messageElem = document.getElementById('message');
  const restartBtn = document.getElementById('restart-btn');

  // Controle de setas
  const keys = { left:false, right:false, up:false, down:false };

  // Botões para setas
  const btnUp = document.getElementById('btn-up');
  const btnDown = document.getElementById('btn-down');
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');

  function setKey(key, val) { keys[key] = val; }
  [btnUp, btnDown, btnLeft, btnRight].forEach(btn => {
    btn.addEventListener('pointerdown', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', true); break;
        case 'btn-down': setKey('down', true); break;
        case 'btn-left': setKey('left', true); break;
        case 'btn-right': setKey('right', true); break;
      }
    });
    btn.addEventListener('pointerup', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', false); break;
        case 'btn-down': setKey('down', false); break;
        case 'btn-left': setKey('left', false); break;
        case 'btn-right': setKey('right', false); break;
      }
    });
    btn.addEventListener('pointerleave', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', false); break;
        case 'btn-down': setKey('down', false); break;
        case 'btn-left': setKey('left', false); break;
        case 'btn-right': setKey('right', false); break;
      }
    });
  });

  // Também teclado
  window.addEventListener('keydown', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = true; break;
      case 'ArrowDown': keys.down = true; break;
      case 'ArrowLeft': keys.left = true; break;
      case 'ArrowRight': keys.right = true; break;
    }
  });
  window.addEventListener('keyup', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = false; break;
      case 'ArrowDown': keys.down = false; break;
      case 'ArrowLeft': keys.left = false; break;
      case 'ArrowRight': keys.right = false; break;
    }
  });

  // Estado do jogo
  let gameOver = false;
  let deathReason = "";

  // Jogador
  const player = {
    x: 0,
    y: 0,
    size: 30,
    speed: 3,
    maxSpeed: 6,
    lives: 2,
    maxLives: 25,
    coins: 0,
    sizeIncrease: 0,
    fastTimer: 0,
    slowEnemyTimer: 0,
    beeHits: 0,  // toques da abelha
    invincibleTimer: 0,
  };
  const INVINCIBLE_TIME = 60; // 1s de invencibilidade

  // Itens no mapa - cada item é {x,y,type,size}
  let coins = [];
  let items = []; // verdes, roxos, laranja, extra
  let enemies = []; // azuis (3), rosa (max), abelha (círculo amarelo)

  // Cores e tamanhos dos itens
  const colors = {
    player: 'red',
    coin: 'yellow',
    enemyCommon: 'blue',
    enemyMax: 'pink',
    bee: 'yellow',
    life: 'green',
    speed: 'purple',
    slowEnemy: 'orange',
    extra: 'cyan',
  };
  const sizes = {
    player: 30,
    coin: 15,
    enemyCommon: 30,
    enemyMax: 40,
    bee: 25,
    life: 20,
    speed: 20,
    slowEnemy: 20,
    extra: 20,
  };

  // Atualiza UI
  function updateUI() {
    lifeCountElem.textContent = player.lives;
    coinCountElem.textContent = player.coins;
  }

  // Função para distância
  function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  // Spawn aleatório em volta do player, fora do raio minDist
  function randomPositionAroundPlayer(minDist=500, maxDist=1000) {
    const angle = Math.random() * 2 * Math.PI;
    const distance = minDist + Math.random() * (maxDist - minDist);
    return {
      x: player.x + Math.cos(angle)*distance,
      y: player.y + Math.sin(angle)*distance
    };
  }

  // Inicializar entidades no mapa
  function initEntities() {
    coins = [];
    items = [];
    enemies = [];

    // Spawn moedas (50)
    for(let i=0; i<50; i++) {
      const pos = randomPositionAroundPlayer(100, 2000);
      coins.push({x: pos.x, y: pos.y, size: sizes.coin});
    }

    // Spawn itens (mais chance de itens que moedas)
    const itemTypes = ['life', 'speed', 'slowEnemy', 'extra'];
    for(let i=0; i<20; i++) {
      const pos = randomPositionAroundPlayer(100, 1800);
      const type = itemTypes[Math.floor(Math.random()*itemTypes.length)];
      items.push({x: pos.x, y: pos.y, type, size: sizes[type]});
    }

    // Spawn inimigos azuis (3)
    for(let i=0; i<3; i++) {
      const pos = randomPositionAroundPlayer(500, 1200);
      enemies.push({x: pos.x, y: pos.y, size: sizes.enemyCommon, speed: 2, type: 'enemyCommon'});
    }

    // Spawn inimigo rosa (1 raro)
    if(Math.random() < 0.3) { // 30% chance
      const pos = randomPositionAroundPlayer(500, 1200);
      enemies.push({x: pos.x, y: pos.y, size: sizes.enemyMax, speed: 1.5, type: 'enemyMax'});
    }

    // Spawn abelha (1 circulo amarelo) raro
    if(Math.random() < 0.2) { // 20% chance
      const pos = randomPositionAroundPlayer(500, 1200);
      enemies.push({x: pos.x, y: pos.y, size: sizes.bee, speed: 3, type: 'bee', hitsOnPlayer: 0, invincibleTimer:0});
    }
  }

  // Colisão entre retângulos
  function rectsCollide(aX,aY,aW,aH,bX,bY,bW,bH) {
    return aX < bX + bW && aX + aW > bX && aY < bY + bH && aY + aH > bY;
  }

  // Colisão círculo e retângulo
  function circleRectCollide(cx,cy,cr,x,y,w,h) {
    let closestX = Math.max(x, Math.min(cx, x + w));
    let closestY = Math.max(y, Math.min(cy, y + h));
    let dx = cx - closestX;
    let dy = cy - closestY;
    return (dx * dx + dy * dy) < (cr * cr);
  }

  // Atualiza posição do jogador baseado nas teclas
  function updatePlayer() {
    if(player.invincibleTimer > 0) player.invincibleTimer--;

    let speed = player.speed;
    if(player.fastTimer > 0) {
      speed = player.maxSpeed;
      player.fastTimer--;
    }

    let dx = 0, dy = 0;
    if(keys.left) dx -= speed;
    if(keys.right) dx += speed;
    if(keys.up) dy -= speed;
    if(keys.down) dy += speed;

    // Normaliza diagonal
    if(dx !== 0 && dy !== 0) {
      dx *= Math.SQRT1_2;
      dy *= Math.SQRT1_2;
    }

    player.x += dx;
    player.y += dy;
  }

  // Atualiza inimigos perseguindo jogador (com distância 600px para seguir)
  function updateEnemies() {
    const slow = player.slowEnemyTimer > 0;
    if(player.slowEnemyTimer > 0) player.slowEnemyTimer--;

    enemies.forEach(e => {
      // Se inimigo está longe demais (>600), ele para de perseguir
      const distance = dist(e, player);
      if(distance > 600) return;

      let speed = e.speed;
      if(slow) speed /= 2;

      let dirX = player.x - e.x;
      let dirY = player.y - e.y;
      let len = Math.sqrt(dirX*dirX + dirY*dirY);
      if(len === 0) return;

      dirX /= len;
      dirY /= len;

      e.x += dirX * speed;
      e.y += dirY * speed;
    });
  }

  // Verifica colisões e aplica efeitos
  function handleCollisions() {
    // Caixa do jogador (centralizado)
    let px = player.x - (player.size + player.sizeIncrease) / 2;
    let py = player.y - (player.size + player.sizeIncrease) / 2;
    let psize = player.size + player.sizeIncrease;

    // Coleta moedas
    coins = coins.filter(c => {
      if(rectsCollide(px, py, psize, psize, c.x - c.size/2, c.y - c.size/2, c.size, c.size)) {
        player.coins++;
        player.sizeIncrease += 1; // cresce 1px por moeda
        if(player.sizeIncrease > 40) player.sizeIncrease = 40; // limite máximo
        updateUI();
        return false; // remove a moeda
      }
      return true;
    });

    // Coleta itens
    items = items.filter(item => {
      if(rectsCollide(px, py, psize, psize, item.x - item.size/2, item.y - item.size/2, item.size, item.size)) {
        if(item.type === 'life') {
          player.lives++;
          if(player.lives > player.maxLives) player.lives = player.maxLives;
        } else if(item.type === 'speed') {
          player.fastTimer = 300; // 5 segundos a 60fps
        } else if(item.type === 'slowEnemy') {
          player.slowEnemyTimer = 300;
        } else if(item.type === 'extra') {
          player.lives += 2;
          if(player.lives > player.maxLives) player.lives = player.maxLives;
        }
        updateUI();
        return false;
      }
      return true;
    });

    // Colisões com inimigos
    enemies.forEach(e => {
      if(player.invincibleTimer > 0) return; // sem dano se invencível

      if(e.type === 'enemyCommon') {
        if(rectsCollide(px, py, psize, psize, e.x - e.size/2, e.y - e.size/2, e.size, e.size)) {
          player.lives--;
          player.invincibleTimer = INVINCIBLE_TIME;
          updateUI();
          if(player.lives <= 0) {
            gameOver = true;
            deathReason = "Você foi morto por inimigo comum!";
          }
        }
      } else if(e.type === 'enemyMax') {
        if(rectsCollide(px, py, psize, psize, e.x - e.size/2, e.y - e.size/2, e.size, e.size)) {
          player.lives -= 5;
          player.invincibleTimer = INVINCIBLE_TIME;
          updateUI();
          if(player.lives <= 0) {
            gameOver = true;
            deathReason = "Você morreu por inimigo max!";
          }
        }
      } else if(e.type === 'bee') {
        if(circleRectCollide(e.x, e.y, e.size/2, px, py, psize, psize)) {
          if(e.invincibleTimer <= 0) {
            e.hitsOnPlayer++;
            e.invincibleTimer = 30; // evita múltiplos toques instantâneos
            if(e.hitsOnPlayer >= 3) {
              gameOver = true;
              deathReason = "Você foi morto por abelha!";
            }
          }
        } else {
          // Resetar hits se afastou
          // (Opcional: pode manter hits para 3 toques consecutivos, mas seu pedido indica resetar)
          e.hitsOnPlayer = 0;
        }
        if(e.invincibleTimer > 0) e.invincibleTimer--;
      }
    });
  }

  // Desenha jogador
  function drawPlayer() {
    ctx.fillStyle = colors.player;
    const size = player.size + player.sizeIncrease;
    ctx.fillRect(
      WIDTH/2 - size/2,
      HEIGHT/2 - size/2,
      size,
      size
    );
  }

  // Desenha moedas
  function drawCoins() {
    ctx.fillStyle = colors.coin;
    coins.forEach(c => {
      const sx = WIDTH/2 + (c.x - player.x);
      const sy = HEIGHT/2 + (c.y - player.y);
      ctx.fillRect(sx - c.size/2, sy - c.size/2, c.size, c.size);
    });
  }

  // Desenha itens
  function drawItems() {
    items.forEach(item => {
      const sx = WIDTH/2 + (item.x - player.x);
      const sy = HEIGHT/2 + (item.y - player.y);
      switch(item.type) {
        case 'life': ctx.fillStyle = colors.life; break;
        case 'speed': ctx.fillStyle = colors.speed; break;
        case 'slowEnemy': ctx.fillStyle = colors.slowEnemy; break;
        case 'extra': ctx.fillStyle = colors.extra; break;
        default: ctx.fillStyle = 'gray';
      }
      ctx.fillRect(sx - item.size/2, sy - item.size/2, item.size, item.size);
    });
  }

  // Desenha inimigos
  function drawEnemies() {
    enemies.forEach(e => {
      const sx = WIDTH/2 + (e.x - player.x);
      const sy = HEIGHT/2 + (e.y - player.y);

      if(e.type === 'bee') {
        ctx.fillStyle = colors.bee;
        ctx.beginPath();
        ctx.arc(sx, sy, e.size/2, 0, Math.PI*2);
        ctx.fill();
      } else {
        switch(e.type) {
          case 'enemyCommon': ctx.fillStyle = colors.enemyCommon; break;
          case 'enemyMax': ctx.fillStyle = colors.enemyMax; break;
          default: ctx.fillStyle = 'black';
        }
        ctx.fillRect(sx - e.size/2, sy - e.size/2, e.size, e.size);
      }
    });
  }

  // Mostra mensagem game over
  function showGameOver() {
    messageElem.textContent = deathReason;
    messageElem.style.display = 'block';
    restartBtn.style.display = 'block';
  }

  // Função para reiniciar o jogo
  function restartGame() {
    gameOver = false;
    deathReason = "";
    player.x = 0;
    player.y = 0;
    player.lives = 2;
    player.coins = 0;
    player.sizeIncrease = 0;
    player.fastTimer = 0;
    player.slowEnemyTimer = 0;
    player.beeHits = 0;
    player.invincibleTimer = 0;
    messageElem.style.display = 'none';
    restartBtn.style.display = 'none';
    initEntities();
    updateUI();
  }

  // Loop principal
  function gameLoop() {
    if(gameOver) {
      showGameOver();
      return;
    }

    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    updatePlayer();
    updateEnemies();

    handleCollisions();

    drawCoins();
    drawItems();
    drawEnemies();
    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  restartBtn.onclick = () => {
    restartGame();
    gameLoop();
  };

  // Inicializa
  restartGame();
  gameLoop();

  // Ajustar canvas se redimensionar janela
  window.addEventListener('resize', () => {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  });
})();
</script>
</body>
</html>
