<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo dos Quadrados Completo</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#fff;
    font-family: Arial, sans-serif;
    user-select:none;
  }
  canvas {
    display:block;
    background: white;
  }
  #ui {
    position: fixed;
    top: 10px; left: 10px;
    color: #333;
    font-weight: bold;
    font-size: 18px;
    z-index: 10;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    font-weight: bold;
    color: red;
    background: rgba(255,255,255,0.9);
    padding: 20px 40px;
    border-radius: 15px;
    display: none;
    z-index: 20;
  }
  #restart-btn {
    position: fixed;
    top: calc(50% + 70px);
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    font-size: 20px;
    border: none;
    border-radius: 12px;
    background: #333;
    color: white;
    cursor: pointer;
    display: none;
    z-index: 20;
  }
  /* Controles setas clicáveis para PS4 cursor */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    width: 180px;
    height: 140px;
    user-select: none;
    z-index: 15;
  }
  .btn-arrow {
    position: absolute;
    width: 60px; height: 60px;
    background: #ccc;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    text-align: center;
    line-height: 60px;
    font-size: 36px;
    cursor: pointer;
    user-select: none;
  }
  .btn-arrow:active {
    background: #aaa;
  }
  #btn-up { top: 0; left: 60px; }
  #btn-left { top: 70px; left: 0; }
  #btn-down { top: 70px; left: 60px; }
  #btn-right { top: 70px; left: 120px; }
</style>
</head>
<body>

<div id="ui">Vidas: <span id="life-count">2</span> &nbsp; Moedas: <span id="coin-count">0</span></div>
<div id="message"></div>
<button id="restart-btn">Reiniciar</button>

<canvas id="game"></canvas>

<div id="controls">
  <div class="btn-arrow" id="btn-up">↑</div>
  <div class="btn-arrow" id="btn-left">←</div>
  <div class="btn-arrow" id="btn-down">↓</div>
  <div class="btn-arrow" id="btn-right">→</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Ajusta tamanho da tela
  let WIDTH = window.innerWidth;
  let HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  // UI elementos
  const lifeCountElem = document.getElementById('life-count');
  const coinCountElem = document.getElementById('coin-count');
  const messageElem = document.getElementById('message');
  const restartBtn = document.getElementById('restart-btn');

  // Controle de setas
  const keys = { left:false, right:false, up:false, down:false };

  // Botões para setas
  const btnUp = document.getElementById('btn-up');
  const btnDown = document.getElementById('btn-down');
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');

  function setKey(key, val) { keys[key] = val; }
  [btnUp, btnDown, btnLeft, btnRight].forEach(btn => {
    btn.addEventListener('pointerdown', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', true); break;
        case 'btn-down': setKey('down', true); break;
        case 'btn-left': setKey('left', true); break;
        case 'btn-right': setKey('right', true); break;
      }
    });
    btn.addEventListener('pointerup', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', false); break;
        case 'btn-down': setKey('down', false); break;
        case 'btn-left': setKey('left', false); break;
        case 'btn-right': setKey('right', false); break;
      }
    });
    btn.addEventListener('pointerleave', e => {
      switch(btn.id) {
        case 'btn-up': setKey('up', false); break;
        case 'btn-down': setKey('down', false); break;
        case 'btn-left': setKey('left', false); break;
        case 'btn-right': setKey('right', false); break;
      }
    });
  });

  // Também teclado
  window.addEventListener('keydown', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = true; break;
      case 'ArrowDown': keys.down = true; break;
      case 'ArrowLeft': keys.left = true; break;
      case 'ArrowRight': keys.right = true; break;
    }
  });
  window.addEventListener('keyup', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = false; break;
      case 'ArrowDown': keys.down = false; break;
      case 'ArrowLeft': keys.left = false; break;
      case 'ArrowRight': keys.right = false; break;
    }
  });

  // Estado do jogo
  let gameOver = false;
  let deathReason = "";

  // Jogador
  const player = {
    x: 0,
    y: 0,
    size: 30,
    speed: 3,
    maxSpeed: 6,
    lives: 2,
    maxLives: 25,
    coins: 0,
    sizeIncrease: 0,
    fastTimer: 0,
    slowEnemyTimer: 0,
    beeHits: 0,  // toques da abelha
  };

  // Mundo infinito, pos player = centro, tudo deslocado em relação a ele

  // Itens no mapa - cada item é {x,y,type}
  let coins = [];
  let items = []; // verdes, roxos, laranja
  let enemies = []; // azuis (3), rosa (max), abelha (círculo amarelo)

  // Cores e tamanhos dos itens
  const colors = {
    player: 'red',
    coin: 'yellow',
    enemyCommon: 'blue',
    enemyMax: 'pink',
    bee: 'yellow',
    life: 'green',
    speed: 'purple',
    slowEnemy: 'orange',
  };
  const sizes = {
    player: 30,
    coin: 15,
    enemyCommon: 30,
    enemyMax: 40,
    bee: 25,
    life: 20,
    speed: 20,
    slowEnemy: 20,
  };

  // Atualiza UI
  function updateUI() {
    lifeCountElem.textContent = player.lives;
    coinCountElem.textContent = player.coins;
  }

  // Função para distância
  function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  // Spawn aleatório em volta do player, fora do raio minDist
  function spawnAroundPlayer(minDist=500, maxDist=1000) {
    const angle = Math.random() * 2 * Math.PI;
    const distRand = minDist + Math.random()*(maxDist - minDist);
    return {
      x: player.x + Math.cos(angle)*distRand,
      y: player.y + Math.sin(angle)*distRand,
    };
  }

  // Criar inimigos azuis (3)
  function spawnEnemiesCommon() {
    while(enemies.filter(e => e.type === 'enemyCommon').length < 3) {
      const pos = spawnAroundPlayer(500, 900);
      enemies.push({
        ...pos,
        type: 'enemyCommon',
        size: sizes.enemyCommon,
        speed: 2,
      });
    }
  }

  // Criar inimigo rosa (max) raro (chance 0.01 por frame)
  function trySpawnEnemyMax() {
    if(enemies.some(e=>e.type === 'enemyMax')) return; // só 1
    if(Math.random() < 0.001) {
      const pos = spawnAroundPlayer(600, 1000);
      enemies.push({
        ...pos,
        type: 'enemyMax',
        size: sizes.enemyMax,
        speed: 1.5,
      });
    }
  }

  // Criar abelha (círculo amarelo) só uma de cada vez
  function trySpawnBee() {
    if(enemies.some(e=>e.type === 'bee')) return;
    if(Math.random() < 0.0008) {
      const pos = spawnAroundPlayer(600, 1200);
      enemies.push({
        ...pos,
        type: 'bee',
        size: sizes.bee,
        speed: 3,
        hitsOnPlayer: 0, // contar toques
      });
    }
  }

  // Itens: vida (green), speed (purple), slowEnemy (orange)
  function trySpawnItem() {
    if(items.length > 20) return;
    if(Math.random() < 0.02) {
      const pos = spawnAroundPlayer(400, 1000);
      const r = Math.random();
      let type = 'life';
      if(r < 0.4) type = 'life';
      else if(r < 0.7) type = 'speed';
      else if(r < 0.95) type = 'slowEnemy';
      else type = 'extra'; // novo item que pode criar

      items.push({
        ...pos,
        type,
        size: sizes.life,
      });
    }
  }

  // Moedas amarelas aparecem diversas pelo mapa
  function trySpawnCoin() {
    if(coins.length > 40) return;
    if(Math.random() < 0.05) {
      const pos = spawnAroundPlayer(100, 1500);
      coins.push({
        ...pos,
        size: sizes.coin,
      });
    }
  }

  // Reinicia jogo
  function restartGame() {
    gameOver = false;
    deathReason = "";
    player.x = 0;
    player.y = 0;
    player.lives = 2;
    player.coins = 0;
    player.sizeIncrease = 0;
    player.fastTimer = 0;
    player.slowEnemyTimer = 0;
    player.beeHits = 0;
    enemies.length = 0;
    coins.length = 0;
    items.length = 0;
    updateUI();
    messageElem.style.display = 'none';
    restartBtn.style.display = 'none';
  }

  // Colisão entre retângulos
  function rectsCollide(aX,aY,aW,aH,bX,bY,bW,bH) {
    return aX < bX + bW && aX + aW > bX && aY < bY + bH && aY + aH > bY;
  }

  // Colisão círculo e retângulo
  function circleRectCollide(cx,cy,cr,x,y,w,h) {
    // encontra o ponto mais próximo na caixa ao círculo
  let closestX = Math.max(x, Math.min(cx, x + w));
    let closestY = Math.max(y, Math.min(cy, y + h));

    let dx = cx - closestX;
    let dy = cy - closestY;

    return (dx * dx + dy * dy) < (cr * cr);
  }

  // Atualiza posição do jogador baseado nas teclas
  function updatePlayer() {
    let speed = player.speed;
    if(player.fastTimer > 0) {
      speed = player.maxSpeed;
      player.fastTimer--;
    }

    let dx = 0, dy = 0;
    if(keys.left) dx -= speed;
    if(keys.right) dx += speed;
    if(keys.up) dy -= speed;
    if(keys.down) dy += speed;

    // Normaliza diagonal
    if(dx !== 0 && dy !== 0) {
      dx *= Math.SQRT1_2;
      dy *= Math.SQRT1_2;
    }

    player.x += dx;
    player.y += dy;
  }

  // Atualiza inimigos perseguindo jogador (com distância 600px para seguir)
  function updateEnemies() {
    const slow = player.slowEnemyTimer > 0;
    if(player.slowEnemyTimer > 0) player.slowEnemyTimer--;

    enemies.forEach(e => {
      // Se inimigo está longe demais (>600), ele para
      const distance = dist(e, player);
      if(distance > 600) return;

      let speed = e.speed;
      if(slow) speed /= 2;

      let dirX = player.x - e.x;
      let dirY = player.y - e.y;
      let len = Math.sqrt(dirX*dirX + dirY*dirY);
      if(len === 0) return;

      dirX /= len;
      dirY /= len;

      e.x += dirX * speed;
      e.y += dirY * speed;
    });
  }

  // Verifica colisões e aplica efeitos
  function handleCollisions() {
    // Jogador caixa
    let px = player.x - player.size/2 - player.sizeIncrease/2;
    let py = player.y - player.size/2 - player.sizeIncrease/2;
    let psize = player.size + player.sizeIncrease;

    // Colete moedas
    coins = coins.filter(c => {
      if(rectsCollide(px, py, psize, psize, c.x - c.size/2, c.y - c.size/2, c.size, c.size)) {
        player.coins++;
        player.sizeIncrease += 1; // cresce 1px por moeda
        if(player.sizeIncrease > 40) player.sizeIncrease = 40; // max crescimento
        updateUI();
        return false; // remove a moeda
      }
      return true;
    });

    // Colete itens
    items = items.filter(item => {
      if(rectsCollide(px, py, psize, psize, item.x - item.size/2, item.y - item.size/2, item.size, item.size)) {
        if(item.type === 'life') {
          player.lives++;
          if(player.lives > player.maxLives) player.lives = player.maxLives;
        } else if(item.type === 'speed') {
          player.fastTimer = 300; // 5 segundos a 60fps
        } else if(item.type === 'slowEnemy') {
          player.slowEnemyTimer = 300;
        } else if(item.type === 'extra') {
          // Item extra que pode fazer algo a mais, por exemplo vida+2
          player.lives += 2;
          if(player.lives > player.maxLives) player.lives = player.maxLives;
        }
        updateUI();
        return false;
      }
      return true;
    });

    // Colisões com inimigos
    enemies.forEach((e, idx) => {
      if(e.type === 'enemyCommon') {
        if(rectsCollide(px, py, psize, psize, e.x - e.size/2, e.y - e.size/2, e.size, e.size)) {
          player.lives--;
          updateUI();
          if(player.lives <= 0) {
            gameOver = true;
            deathReason = "Você foi morto por inimigo comum!";
          }
        }
      } else if(e.type === 'enemyMax') {
        if(rectsCollide(px, py, psize, psize, e.x - e.size/2, e.y - e.size/2, e.size, e.size)) {
          player.lives -= 5;
          updateUI();
          if(player.lives <= 0) {
            gameOver = true;
            deathReason = "Você morreu por inimigo max!";
          }
        }
      } else if(e.type === 'bee') {
        if(circleRectCollide(e.x, e.y, e.size/2, px, py, psize, psize)) {
          e.hitsOnPlayer++;
          if(e.hitsOnPlayer >= 3) {
            gameOver = true;
            deathReason = "Você foi morto por abelha!";
          }
        } else {
          // Se afastou, resetar hits
          e.hitsOnPlayer = 0;
        }
      }
    });
  }

  // Desenha jogador
  function drawPlayer() {
    ctx.fillStyle = colors.player;
    const size = player.size + player.sizeIncrease;
    ctx.fillRect(
      WIDTH/2 - size/2,
      HEIGHT/2 - size/2,
      size,
      size
    );
  }

  // Desenha moedas
  function drawCoins() {
    ctx.fillStyle = colors.coin;
    coins.forEach(c => {
      const sx = WIDTH/2 + (c.x - player.x);
      const sy = HEIGHT/2 + (c.y - player.y);
      ctx.fillRect(sx - c.size/2, sy - c.size/2, c.size, c.size);
    });
  }

  // Desenha itens
  function drawItems() {
    items.forEach(item => {
      const sx = WIDTH/2 + (item.x - player.x);
      const sy = HEIGHT/2 + (item.y - player.y);
      switch(item.type) {
        case 'life': ctx.fillStyle = colors.life; break;
        case 'speed': ctx.fillStyle = colors.speed; break;
        case 'slowEnemy': ctx.fillStyle = colors.slowEnemy; break;
        case 'extra': ctx.fillStyle = 'cyan'; break;
        default: ctx.fillStyle = 'gray';
      }
      ctx.fillRect(sx - item.size/2, sy - item.size/2, item.size, item.size);
    });
  }

  // Desenha inimigos
  function drawEnemies() {
    enemies.forEach(e => {
      const sx = WIDTH/2 + (e.x - player.x);
      const sy = HEIGHT/2 + (e.y - player.y);

      if(e.type === 'bee') {
        ctx.fillStyle = colors.bee;
        ctx.beginPath();
        ctx.arc(sx, sy, e.size/2, 0, Math.PI*2);
        ctx.fill();
      } else {
        switch(e.type) {
          case 'enemyCommon': ctx.fillStyle = colors.enemyCommon; break;
          case 'enemyMax': ctx.fillStyle = colors.enemyMax; break;
          default: ctx.fillStyle = 'black';
        }
        ctx.fillRect(sx - e.size/2, sy - e.size/2, e.size, e.size);
      }
    });
  }

  // Mostra mensagem game over
  function showGameOver() {
    messageElem.textContent = deathReason;
    messageElem.style.display = 'block';
    restartBtn.style.display = 'block';
  }

  // Loop principal
  function gameLoop() {
    if(gameOver) {
      showGameOver();
      return;
    }

    // Fundo branco
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    updatePlayer();
    updateEnemies();

    handleCollisions();

    // Spawn entidades
    spawnEnemiesCommon();
    trySpawnEnemyMax();
    trySpawnBee();
    trySpawnCoin();
    trySpawnItem();

    drawCoins();
    drawItems();
    drawEnemies();
    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  restartBtn.onclick = () => {
    restartGame();
    gameLoop();
  };

  // Inicializa
  restartGame();
  gameLoop();

  // Ajustar canvas se redimensionar janela
  window.addEventListener('resize', () => {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  });
})();
</script>
</body>
</html>
