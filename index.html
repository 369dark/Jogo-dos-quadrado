<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo dos Quadrados Completo</title>
<style>
  body, html {
    margin:0; padding:0; overflow:hidden; background:#fff;
    font-family: Arial, sans-serif;
    user-select:none;
  }
  canvas {
    display:block;
    background: white;
  }
  #ui {
    position: fixed;
    top: 10px; left: 10px;
    color: #333;
    font-weight: bold;
    font-size: 18px;
    z-index: 10;
  }
  #message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 36px;
    font-weight: bold;
    color: red;
    background: rgba(255,255,255,0.9);
    padding: 20px 40px;
    border-radius: 15px;
    display: none;
    z-index: 20;
    max-width: 90vw;
    text-align: center;
  }
  #restart-btn {
    position: fixed;
    top: calc(50% + 70px);
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    font-size: 20px;
    border: none;
    border-radius: 12px;
    background: #333;
    color: white;
    cursor: pointer;
    display: none;
    z-index: 20;
  }
  /* Controles setas clicáveis para PS4 cursor */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    width: 180px;
    height: 140px;
    user-select: none;
    z-index: 15;
  }
  .btn-arrow {
    position: absolute;
    width: 60px; height: 60px;
    background: #ccc;
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    text-align: center;
    line-height: 60px;
    font-size: 36px;
    cursor: pointer;
    user-select: none;
  }
  .btn-arrow:active {
    background: #aaa;
  }
  #btn-up { top: 0; left: 60px; }
  #btn-left { top: 70px; left: 0; }
  #btn-down { top: 70px; left: 60px; }
  #btn-right { top: 70px; left: 120px; }
</style>
</head>
<body>

<div id="ui">Vidas: <span id="life-count">2</span> &nbsp; Moedas: <span id="coin-count">0</span></div>
<div id="message"></div>
<button id="restart-btn">Reiniciar</button>

<canvas id="game"></canvas>

<div id="controls">
  <div class="btn-arrow" id="btn-up">↑</div>
  <div class="btn-arrow" id="btn-left">←</div>
  <div class="btn-arrow" id="btn-down">↓</div>
  <div class="btn-arrow" id="btn-right">→</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let WIDTH = window.innerWidth;
  let HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  const lifeCountElem = document.getElementById('life-count');
  const coinCountElem = document.getElementById('coin-count');
  const messageElem = document.getElementById('message');
  const restartBtn = document.getElementById('restart-btn');

  const keys = { left:false, right:false, up:false, down:false };

  // Botões setas para toque
  ['up', 'down', 'left', 'right'].forEach(dir => {
    const btn = document.getElementById('btn-' + dir);
    btn.addEventListener('pointerdown', () => { keys[dir] = true; });
    btn.addEventListener('pointerup', () => { keys[dir] = false; });
    btn.addEventListener('pointerleave', () => { keys[dir] = false; });
  });

  window.addEventListener('keydown', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = true; break;
      case 'ArrowDown': keys.down = true; break;
      case 'ArrowLeft': keys.left = true; break;
      case 'ArrowRight': keys.right = true; break;
    }
  });
  window.addEventListener('keyup', e => {
    switch(e.key) {
      case 'ArrowUp': keys.up = false; break;
      case 'ArrowDown': keys.down = false; break;
      case 'ArrowLeft': keys.left = false; break;
      case 'ArrowRight': keys.right = false; break;
    }
  });

  let gameOver = false;
  let deathReason = "";

  const player = {
    x: 0,
    y: 0,
    size: 30,
    speed: 3,
    maxSpeed: 6,
    lives: 2,
    maxLives: 25,
    coins: 0,
    sizeIncrease: 0,
    fastTimer: 0,
    slowEnemyTimer: 0,
    shieldTimer: 0,
    beeHits: 0,
  };

  let coins = [];
  let items = [];
  let enemies = [];

  const colors = {
    player: 'red',
    coin: 'yellow',
    enemyCommon: 'blue',
    enemyMax: 'pink',
    bee: 'yellow',
    life: 'green',
    speed: 'purple',
    slowEnemy: 'orange',
    shield: 'cyan',
  };

  const sizes = {
    player: 30,
    coin: 15,
    enemyCommon: 30,
    enemyMax: 40,
    bee: 25,
    life: 20,
    speed: 20,
    slowEnemy: 20,
    shield: 40,
  };

  function updateUI() {
    lifeCountElem.textContent = player.lives;
    coinCountElem.textContent = player.coins;
  }

  function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }

  function spawnAroundPlayer(minDist=500, maxDist=1000) {
    const angle = Math.random() * 2 * Math.PI;
    const distRand = minDist + Math.random()*(maxDist - minDist);
    return {
      x: player.x + Math.cos(angle) * distRand,
      y: player.y + Math.sin(angle) * distRand
    };
  }

  // Spawn inicial
  function spawnInitial() {
    coins = [];
    items = [];
    enemies = [];

    // Spawn 50 moedas espalhadas
    for(let i=0; i<50; i++) {
      let pos = spawnAroundPlayer(500, 1500);
      coins.push({x: pos.x, y: pos.y, size: sizes.coin});
    }

    // Spawn 3 inimigos comuns
    for(let i=0; i<3; i++) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.enemyCommon,
        speed: 1.5,
        type: 'enemyCommon',
        lastHitTime: 0,
      });
    }

    // Spawn inimigo max rosa (raro)
    if(Math.random() < 0.2) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.enemyMax,
        speed: 1,
        type: 'enemyMax',
        lastHitTime: 0,
      });
    }

    // Spawn abelha (circulo amarelo) - só 1 abelha por vez
    if(Math.random() < 0.3) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.bee,
        speed: 2,
        type: 'bee',
        hitsOnPlayer: 0,
        lastHitTime: 0,
      });
    }

    // Spawn itens (verde, roxo, laranja, ciano escudo)
    const itemTypes = ['life', 'speed', 'slowEnemy', 'shieldExtra'];
    for(let i=0; i<10; i++) {
      let pos = spawnAroundPlayer(500, 1500);
      let type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      items.push({
        x: pos.x,
        y: pos.y,
        size: sizes[type],
        type,
      });
    }

    // Reset player estado
    player.x = 0;
    player.y = 0;
    player.lives = 5;
    player.coins = 0;
    player.sizeIncrease = 0;
    player.fastTimer = 0;
    player.slowEnemyTimer = 0;
    player.shieldTimer = 0;
    player.beeHits = 0;
    gameOver = false;
    deathReason = "";
    updateUI();
  }

  function rectsCollide(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function circleRectCollide(cx, cy, cr, rx, ry, rw, rh) {
    let closestX = Math.max(rx, Math.min(cx, rx + rw));
    let closestY = Math.max(ry, Math.min(cy, ry + rh));

    let dx = cx - closestX;
    let dy = cy - closestY;

    return (dx * dx + dy * dy) < (cr * cr);
  }

  function updatePlayer() {
    let speed = player.speed;
    if(player.fastTimer > 0) {
      speed = player.maxSpeed;
      player.fastTimer--;
    }
    if(player.slowEnemyTimer > 0) {
      player.slowEnemyTimer--;
    }
    if(player.shieldTimer > 0) {
      player.shieldTimer--;
    }

    let dx = 0, dy = 0;
    if(keys.left) dx -= speed;
    if(keys.right) dx += speed;
    if(keys.up) dy -= speed;
    if(keys.down) dy += speed;

    if(dx !== 0 && dy !== 0) {
      dx *= Math.SQRT1_2;
      dy *= Math.SQRT1_2;
    }

    player.x += dx;
    player.y += dy;
  }

  function updateEnemies() {
    const slow = player.slowEnemyTimer > 0;
    enemies.forEach(e => {
      const distance = dist(e, player);
      if(distance > 600) return;

      let speed = e.speed;
      if(slow) speed /= 2;

      let dirX = player.x - e.x;
      let dirY = player.y - e.y;
      let len = Math.sqrt(dirX*dirX + dirY*dirY);
      if(len === 0) return;

      dirX /= len;
      dirY /= len;

      e.x += dirX * speed;
      e.y += dirY * speed;
    });
  }

  function canDamage(lastHitTime) {
    const now = performance.now();
    return !lastHitTime || (now - lastHitTime > 1000); // 1 seg cooldown
  }

  function handleCollisions() {
    const pSize = player.size + player.sizeIncrease;
    const px = player.x - pSize/2;
    const py = player.y - pSize/2;

    // Moedas
    coins = coins.filter(c => {
      if(rectsCollide(px, py, pSize, pSize, c.x - c.size/2, c.y - c.size/2, c.size, c.size)) {
        player.coins++;
        player.sizeIncrease += 1;
        if(player.sizeIncrease > 40) player.sizeIncrease = 40;
        updateUI();
        return false;
      }
      return true;
    });

    // Itens
    items = items.filter(item => {
      if(rectsCollide(px, py, pSize, pSize, item.x - item.size/2, item.y - item.size/2, item.size, item.size)) {
        switch(item.type) {
          case 'life':
            player.lives++;
            if(player.lives > player.maxLives) player.lives = player.maxLives;
            break;
          case 'speed':
            player.fastTimer = 300; // 5 segundos a 60fps
            break;
          case 'slowEnemy':
            player.slowEnemyTimer = 300;
            break;
          case 'shieldExtra':
            player.shieldTimer = 600; // escudo dura 10 segundos
            break;
        }
        updateUI();
        return false;
      }
      return true;
    });

    // Colisões com inimigos
    const now = performance.now();
    enemies.forEach(e => {
      const eSize = e.size;
      const ex = e.x - eSize/2;
      const ey = e.y - eSize/2;
      if(e.type === 'enemyCommon') {
        if(rectsCollide(px, py, pSize, pSize, ex, ey, eSize, eSize)) {
          if(canDamage(e.lastHitTime)) {
            if(player.shieldTimer > 0) {
              // Escudo bloqueia dano
              e.lastHitTime = now;
            } else {
              player.lives--;
              e.lastHitTime = now;
              updateUI();
              if(player.lives <= 0) {
                gameOver = true;
                deathReason = "Você foi morto por inimigo comum!";
              }
            }
          }
        }
      } else if(e.type === 'enemyMax') {
        if(rectsCollide(px, py, pSize, pSize, ex, ey, eSize, eSize)) {
          if(canDamage(e.lastHitTime)) {
            if(player.shieldTimer > 0) {
              e.lastHitTime = now;
            } else {
              player.lives -= 5;
              e.lastHitTime = now;
              updateUI();
              if(player.lives <= 0) {
                gameOver = true;
                deathReason = "Você morreu por inimigo max!";
              }
            }
          }
        }
      } else if(e.type === 'bee') {
        if(circleRectCollide(e.x, e.y, e.size/2, px, py, pSize, pSize)) {
          if(canDamage(e.lastHitTime)) {
            e.hitsOnPlayer++;
            e.lastHitTime = now;
            if(player.shieldTimer > 0) {
              // Escudo bloqueia hit da abelha (não acumula hits)
              e.hitsOnPlayer = 0;
            } else {
              if(e.hitsOnPlayer >= 3) {
                gameOver = true;
                deathReason = "Você foi morto por abelha!";
              }
            }
          }
        } else {
          // Se abelha se afastou, reseta contagem
          if(e.hitsOnPlayer > 0 && now - e.lastHitTime > 2000) {
            e.hitsOnPlayer = 0;
          }
        }
      }
    });
  }

  // Desenhar jogador (com escudo ciano se ativo)
  function drawPlayer() {
    const size = player.size + player.sizeIncrease;
    const cx = WIDTH/2;
    const cy = HEIGHT/2;
    // Jogador vermelho
    ctx.fillStyle = colors.player;
    ctx.fillRect(cx - size/2, cy - size/2, size, size);

    // Escudo ciano se ativo
    if(player.shieldTimer > 0) {
      ctx.strokeStyle = colors.shield;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.rect(cx - size/2 - 5, cy - size/2 - 5, size + 10, size + 10);
      ctx.stroke();
    }
  }

  function drawCoins() {
    ctx.fillStyle = colors.coin;
    coins.forEach(c => {
      const sx = WIDTH/2 + (c.x - player.x);
      const sy = HEIGHT/2 + (c.y - player.y);
      ctx.fillRect(sx - c.size/2, sy - c.size/2, c.size, c.size);
    });
  }

  function drawItems() {
    items.forEach(item => {
      const sx = WIDTH/2 + (item.x - player.x);
      const sy = HEIGHT/2 + (item.y - player.y);
      switch(item.type) {
        case 'life': ctx.fillStyle = colors.life; break;
        case 'speed': ctx.fillStyle = colors.speed; break;
        case 'slowEnemy': ctx.fillStyle = colors.slowEnemy; break;
        case 'shieldExtra': ctx.fillStyle = colors.shield; break;
        default: ctx.fillStyle = 'gray';
      }
      ctx.fillRect(sx - item.size/2, sy - item.size/2, item.size, item.size);
    });
  }

  function drawEnemies() {
    enemies.forEach(e => {
      const sx = WIDTH/2 + (e.x - player.x);
      const sy = HEIGHT/2 + (e.y - player.y);

      if(e.type === 'bee') {
        ctx.fillStyle = colors.bee;
        ctx.beginPath();
        ctx.arc(sx, sy, e.size/2, 0, Math.PI*2);
        ctx.fill();
      } else {
        switch(e.type) {
          case 'enemyCommon': ctx.fillStyle = colors.enemyCommon; break;
          case 'enemyMax': ctx.fillStyle = colors.enemyMax; break;
          default: ctx.fillStyle = 'gray';
        }
        ctx.fillRect(sx - e.size/2, sy - e.size/2, e.size, e.size);
      }
    });
  }

  function showGameOver() {
    messageElem.textContent = deathReason;
    messageElem.style.display = 'block';
    restartBtn.style.display = 'block';
  }

  function gameLoop() {
    if(gameOver) {
      showGameOver();
      return;
    }
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    updatePlayer();
    updateEnemies();
    handleCollisions();

    // Spawn frequente de inimigos/moedas/itens
    if(enemies.filter(e => e.type === 'enemyCommon').length < 3) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.enemyCommon,
        speed: 1.5,
        type: 'enemyCommon',
        lastHitTime: 0,
      });
    }
    if(enemies.filter(e => e.type === 'enemyMax').length < 1 && Math.random() < 0.005) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.enemyMax,
        speed: 1,
        type: 'enemyMax',
        lastHitTime: 0,
      });
    }
    if(enemies.filter(e => e.type === 'bee').length < 1 && Math.random() < 0.005) {
      let pos = spawnAroundPlayer(500, 1500);
      enemies.push({
        x: pos.x, y: pos.y,
        size: sizes.bee,
        speed: 2,
        type: 'bee',
        hitsOnPlayer: 0,
        lastHitTime: 0,
      });
    }
    if(coins.length < 50 && Math.random() < 0.02) {
      let pos = spawnAroundPlayer(500, 1500);
      coins.push({x: pos.x, y: pos.y, size: sizes.coin});
    }
    if(items.length < 10 && Math.random() < 0.01) {
      let pos = spawnAroundPlayer(500, 1500);
      const itemTypes = ['life', 'speed', 'slowEnemy', 'shieldExtra'];
      let type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      items.push({
        x: pos.x, y: pos.y, size: sizes[type], type
      });
    }

    drawCoins();
    drawItems();
    drawEnemies();
    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  restartBtn.onclick = () => {
    messageElem.style.display = 'none';
    restartBtn.style.display = 'none';
    spawnInitial();
    gameLoop();
  };

  // Inicializa jogo
  spawnInitial();
  gameLoop();

  window.addEventListener('resize', () => {
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
  });
})();
</script>

</body>
</html>
